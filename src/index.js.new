const fs = require('fs')
const path = require('path')
const axios = require('axios')
const { Client, LocalAuth } = require('whatsapp-web.js')
const AdmZip = require('adm-zip')
const CommandConverter = require('./lib/CommandConverter')
const { logMessageDetails, extractMessageContent } = require('./lib/debugUtils')

// Configuration for handling self-messages
const DEBUG = {
    ALLOW_SELF_MESSAGES: true,
    VERBOSE_LOGGING: true
}

const config = JSON.parse(fs.readFileSync(path.join(__dirname, 'config.json')))
const emojis = JSON.parse(fs.readFileSync(path.join(__dirname, 'emojis.json')))

// pairs storage
const pairsFile = path.join(__dirname, 'pairs.json')
let pairs = {}
try { pairs = JSON.parse(fs.readFileSync(pairsFile)) } catch (e) { pairs = {} }

function savePairs() { fs.writeFileSync(pairsFile, JSON.stringify(pairs, null, 2)) }

if (typeof config.private === 'undefined') config.private = true
if (typeof config.suppressQR === 'undefined') config.suppressQR = false

function saveConfig() {
  fs.writeFileSync(path.join(__dirname, 'config.json'), JSON.stringify(config, null, 2))
}

const readline = require('readline')

// Pair-code session storage
const sessionsRoot = path.join(__dirname, 'sessions')
if (!fs.existsSync(sessionsRoot)) fs.mkdirSync(sessionsRoot, { recursive: true })

let client = null
let chosenAuthDir = null

function ask(question) {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout })
  return new Promise(resolve => rl.question(question, ans => { rl.close(); resolve(ans); }))
}

async function startPairFlow() {
  while (true) {
    console.log('\nPair-code authentication flow (no QR will be shown).')
    console.log("Options:")
    console.log("1. Enter an existing pair code to use it")
    console.log("2. Type 'get' to generate a new pair code")
    console.log("3. Type 'import' to import a session")
    console.log("4. Type 'exit' to quit")
    const opt = (await ask('Enter your choice: ')).trim().toLowerCase()

    if (!opt) {
      console.log('No input provided. Please make a selection.')
      continue
    }

    if (opt === 'exit') {
      console.log('Exiting MazariBot. Bye!')
      process.exit(0)
    }

    if (opt === 'get') {
      const phoneNumber = (await ask('Enter your WhatsApp number (e.g., 91702395XXXX): ')).trim()
      if (!phoneNumber) {
        console.log('No phone number provided. Returning to main menu.')
        continue
      }

      console.log('Generating pair code...')
      try {
        const response = await axios.get(`https://knight-bot-paircode.onrender.com/code?number=${phoneNumber}`)
        if (response.data && response.data.code) {
          if (response.data.code === "Service Unavailable") {
            console.log('Service is currently unavailable. Please try again later.')
          } else {
            console.log(`Your pair code is: ${response.data.code}`)
            console.log('Use this code in your WhatsApp mobile app to connect.')
          }
        }
      } catch (error) {
        console.error('Failed to generate pair code:', error.message)
      }
      await new Promise(resolve => setTimeout(resolve, 3000))
      continue
    }

    if (opt === 'import') {
      const code = (await ask('Enter pair code to assign this session to (short text): ')).trim()
      if (!code) { console.log('No code entered. Returning to main menu.'); continue }
      const b64 = (await ask('Paste session zip as BASE64 (single line) and press Enter: ')).trim()
      if (!b64) { console.log('No session data provided. Returning to main menu.'); continue }

      const dest = path.join(sessionsRoot, code)
      try {
        if (fs.existsSync(dest)) fs.rmSync(dest, { recursive: true, force: true })
        fs.mkdirSync(dest, { recursive: true })
        const zipPath = path.join(dest, 'session.zip')
        fs.writeFileSync(zipPath, Buffer.from(b64, 'base64'))
        const zip = new AdmZip(zipPath)
        zip.extractAllTo(dest, true)
        fs.unlinkSync(zipPath)

        pairs[code] = { authDir: dest, created: new Date().toISOString() }
        savePairs()
        chosenAuthDir = dest
        console.log(`Imported session for code '${code}'`)
        break
      } catch (e) {
        console.error('Failed to import session:', e)
        continue
      }
    } else {
      const code = opt
      if (!pairs[code] || !pairs[code].authDir || !fs.existsSync(pairs[code].authDir)) {
        console.log(`Pair code '${code}' not found or session directory missing.`)
        console.log('If you have a session zip, type import to add it, or try another code.')
        continue
      }
      chosenAuthDir = pairs[code].authDir
      console.log(`Using session for code '${code}'`)
      break
    }
  }

  // create client with chosen auth dir
  client = new Client({
    authStrategy: new LocalAuth({ clientId: 'mazaribot', dataPath: chosenAuthDir }),
    puppeteer: { 
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu'
      ]
    }
  })

  // Attach event handlers
  client.on('ready', async () => {
    console.log('MazariBot ready')
    console.log('Bot info:', {
      private: config.private,
      owners: config.owners,
      autoStatusSeen: config.autoStatusSeen,
      autoReply: config.autoReply,
      autoReact: config.autoReact
    })
    await notifyOwnersConnected()
    console.log('Ready to process commands')
  })

  client.on('message', async msg => {
    try {
      const { isSelfMessage } = logMessageDetails(msg, client)
      
      if (msg.from === 'status@broadcast') {
        console.log('Ignoring status message')
        return
      }

      const messageContent = extractMessageContent(msg)
      if (DEBUG.VERBOSE_LOGGING) {
        console.log('Extracted message content:', messageContent)
      }

      if (msg.fromMe && !DEBUG.ALLOW_SELF_MESSAGES) {
        if (DEBUG.VERBOSE_LOGGING) {
          console.log('Ignoring self-message (ALLOW_SELF_MESSAGES is false)')
        }
        return
      }

      const contact = await msg.getContact()
      const chat = await msg.getChat()
      const isGroup = chat.isGroup
      const senderId = contact.id._serialized
      
      let contactNumber = contact.number || contact.id?.user
      if (!contactNumber && contact.id?._serialized) {
          contactNumber = contact.id._serialized.split('@')[0]
      }
      
      const isFromMe = msg.fromMe || msg._data?.fromMe || false
      const isOwner = isFromMe || config.owners.some(owner => {
          const cleanOwner = owner.replace(/[^0-9]/g, '')
          const cleanContact = contactNumber.replace(/[^0-9]/g, '')
          return cleanContact.includes(cleanOwner) || cleanOwner.includes(cleanContact)
      })
      
      if (DEBUG.VERBOSE_LOGGING) {
        console.log(`Message from ${contact.pushname || contactNumber} (${senderId}):
        Type: ${msg.type}
        Content: ${msg.body}
        Is Owner: ${isOwner}
        From Me: ${isFromMe}`)
      }

      if (config.autoStatusSeen && !isGroup) {
        try { await client.sendReadReceipt(senderId, msg.id._serialized) } catch (e) { 
          console.error('Error sending read receipt:', e)
        }
      }

      if (config.autoReact) {
        const emoji = emojis[Math.floor(Math.random() * emojis.length)]
        try { await msg.react(emoji) } catch (e) {
          console.error('Error auto reacting:', e)
        }
      }

      if (config.autoReply && !isGroup) {
        try { await msg.reply(config.welcomeMessage) } catch (e) {
          console.error('Error auto replying:', e)
        }
      }

      // Command handling
      const text = messageContent || msg.body || ''
      if (!text.startsWith(config.prefix || '.')) return

      const commandName = text.split(' ')[0].slice((config.prefix || '.').length).toLowerCase()
      const isAllowed = !isGroup || isOwner || pairs[contactNumber]
      
      if (!isAllowed) {
        if (DEBUG.VERBOSE_LOGGING) console.log('Ignoring command from non-owner in group chat')
        return
      }

      console.log(`Command detected: ${commandName} From: ${contact.pushname || contactNumber}`)

      const commandPath = path.join(__dirname, '..', 'commands', `${commandName}.js`)
      try {
        if (!fs.existsSync(commandPath)) {
          await msg.reply('❌ Unknown command. Use .help to see available commands.')
          return
        }

        const converted = await CommandConverter.convertCommand(commandPath, commandName)
        const result = await converted.handleCommand(client, chat, msg, text.split(' ').slice(1))
        if (result && result.message) await msg.reply(result.message)
      } catch (error) {
        console.error('Error executing command:', error)
        try { await msg.reply('❌ Error executing command: ' + error.message) } catch (e) {}
      }
    } catch (error) {
      console.error('Error processing message:', error)
    }
  })

  client.on('authenticated', () => {
    console.log('WhatsApp authentication successful')
  })

  client.on('auth_failure', (error) => {
    console.error('WhatsApp authentication failed:', error)
  })

  client.on('disconnected', (reason) => {
    console.log('WhatsApp disconnected:', reason)
  })

  // Initialize the client
  try {
    await client.initialize()
    console.log('Client initialized successfully')
  } catch (error) {
    console.error('Failed to initialize client:', error)
    process.exit(1)
  }
}

async function notifyOwnersConnected() {
  const info = `MazariBot connected successfully.\nOwners: ${config.ownerNames.join(', ')} (${config.owners.join(', ')})\nChannels:\n${config.channels.join('\n')}`
  for (const o of config.owners) {
    try { await client.sendMessage(o + '@c.us', info) } catch (e) { }
  }
}

// Start the bot with pair code authentication
console.log('Starting MazariBot...')
startPairFlow()