const fs = require('fs');
const path = require('path');

// Path to store auto status configuration
const configPath = path.join(__dirname, '../data/autoStatus.json');

// Keep track of recently viewed statuses to prevent duplicates
const recentlyViewed = new Set();
const CACHE_EXPIRY = 5 * 60 * 1000; // 5 minutes

// Channel info for message formatting
const channelInfo = {
    contextInfo: {
        forwardingScore: 1,
        isForwarded: true,
        forwardedNewsletterMessageInfo: {
            newsletterJid: '0029Vb6GUj8BPzjOWNfnhm1B@newsletter',
            newsletterName: 'MAZARI TECH',
            serverMessageId: -1
        }
    }
};

// Initialize config file and directory if they don't exist
try {
    const dataDir = path.dirname(configPath);
    if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true });
    }
    if (!fs.existsSync(configPath)) {
        fs.writeFileSync(configPath, JSON.stringify({ enabled: false }));
    }
} catch (err) {
    console.error("Error initializing autoStatus.json:", err);
}

module.exports = {
    info: {
        name: 'autostatus',
        description: 'Configure auto status viewing',
        ownerOnly: true
    },

    async handleCommand(client, chat, msg, args) {
        try {
            // Read current config
            let config = JSON.parse(fs.readFileSync(configPath));

            // If no arguments, show current status
            if (!args || args.length === 0) {
                const status = config.enabled ? 'enabled' : 'disabled';
                return {
                    success: true,
                    message: `üîÑ *Auto Status View*\n\nCurrent status: ${status}\n\nUse:\n.autostatus on - Enable auto status view\n.autostatus off - Disable auto status view`
                };
            }

            // Handle on/off commands
            const command = args[0].toLowerCase();
            if (command === 'on') {
                config.enabled = true;
                fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
                return {
                    success: true,
                    message: '‚úÖ Auto status view has been enabled!\nBot will now automatically view all contact statuses.'
                };
            } else if (command === 'off') {
                config.enabled = false;
                fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
                return {
                    success: true,
                    message: '‚ùå Auto status view has been disabled!\nBot will no longer automatically view statuses.'
                };
            } else {
                return {
                    success: false,
                    message: '‚ùå Invalid command! Use:\n.autostatus on - Enable auto status view\n.autostatus off - Disable auto status view'
                };
            }
        } catch (error) {
            console.error('Error in autostatus command:', error);
            return {
                success: false,
                message: '‚ùå Error occurred while managing auto status!\n' + error.message
            };
        }
    },

    isAutoStatusEnabled() {
        try {
            const config = JSON.parse(fs.readFileSync(configPath));
            return config.enabled;
        } catch (error) {
            console.error('Error checking auto status config:', error);
            return false;
        }
    },

    async handleStatusUpdate(client, status) {
        try {
            if (!this.isAutoStatusEnabled()) {
                return;
            }

            // Get key to read
            let keyToRead = null;
            let statusId = null;

            if (status.messages && status.messages.length > 0) {
                const msg = status.messages[0];
                if (msg.key && msg.key.remoteJid === 'status@broadcast') {
                    keyToRead = msg.key;
                    statusId = `${msg.key.id}_${msg.key.participant || msg.key.remoteJid}`;
                }
            } else if (status.key && status.key.remoteJid === 'status@broadcast') {
                keyToRead = status.key;
                statusId = `${status.key.id}_${status.key.participant || status.key.remoteJid}`;
            } else if (status.reaction && status.reaction.key.remoteJid === 'status@broadcast') {
                keyToRead = status.reaction.key;
                statusId = `${status.reaction.key.id}_${status.reaction.key.participant || status.reaction.key.remoteJid}`;
            }

            if (keyToRead && statusId && !recentlyViewed.has(statusId)) {
                try {
                    // Add rate limiting
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Mark status as read
                    await client.readMessages([keyToRead]);
                    console.log(`‚úÖ Viewed status from: ${keyToRead.participant || keyToRead.remoteJid}`);
                    
                    // Add to recently viewed cache
                    recentlyViewed.add(statusId);
                    setTimeout(() => recentlyViewed.delete(statusId), CACHE_EXPIRY);

                } catch (err) {
                    if (err.message?.includes('rate-overlimit')) {
                        console.log('‚ö†Ô∏è Rate limit hit, will try again later...');
                    } else {
                        console.error('‚ùå Error reading status:', err.message);
                    }
                }
            }
        } catch (error) {
            console.error('‚ùå Error in auto status view:', error.message);
        }
    }
};